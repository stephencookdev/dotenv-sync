// note, #~~ is considered a special comment, and should _not_ exist
// as something the user writes themselves, but for making groups

const watermark = `
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#~~            This file is autogenerated            ~~#
#~~      any unsynced edits will be overwritten      ~~#
#~~                        ~                         ~~#
#~~   Everything here should be considered secret    ~~#
#~~                 Do not share it                  ~~#
#~~                        ~                         ~~#
#~~ To sync edits here, run \`$(npm bin)/dotenv-sync\` ~~#
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
`.trim();
const secretKeyStringGen = (key) =>
  `
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
#~~   The following is internal data for dotenv-sync   ~~#
#~~ Changing anything here could cause things to break ~~#
#~~                         ~                          ~~#
#~~ secretKey::::${key}
#~~ version::::0.1
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#
`.trim();

function parse(str) {
  const internalCommentRegex = /^#~~.*$/gm;
  const headerReg = /^#~~~\s*([A-za-z]+)\s*$/gm;

  const envGroups = str
    .split(headerReg)
    .map((s) => s.replace(internalCommentRegex, "").trim())
    .filter(Boolean);

  const env = {};

  // if we have an odd number of groups, it means we have
  // e.g. common/group title/group
  // whereas an even number must mean no common
  // e.g. group title/group/group title/group
  const hasCommon = envGroups.length % 2 === 1;
  if (hasCommon) {
    env.__base = envGroups[0];
  }

  for (let i = hasCommon ? 1 : 0; i + 1 < envGroups.length; i += 2) {
    env[envGroups[i]] = envGroups[i + 1];
  }

  const secretKey = (/^#~~ secretKey::::([^\s]+)(\s.*)?$/m.exec(str) || [])[1];

  return { env, secretKey };
}

function stringify(env, secretKey) {
  const strParts = Object.keys(env).map((key) => {
    const keyVal = env[key].trim();

    if (key === "__base") return keyVal;
    return `#~~~ ${key}\n${keyVal}`;
  });

  const stringified = strParts.join("\n\n");
  if (secretKey && secretKey.__omit) {
    return stringified;
  }

  return (
    watermark +
    "\n".repeat(2) +
    stringified +
    "\n".repeat(50) +
    secretKeyStringGen(secretKey)
  );
}

module.exports = {
  parse,
  stringify,
};
